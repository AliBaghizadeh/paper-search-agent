{
  "name": "Paper Search Agent",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.4,
      "position": [
        -1104,
        -224
      ],
      "id": "40e474d7-d02f-48c6-b0b1-6d7596fa8fff",
      "name": "When chat message received",
      "webhookId": "9629ba84-d597-4f40-a06a-8248f6708989"
    },
    {
      "parameters": {
        "jsCode": "const user = $json.original_query;\n\nconst system = `\nYou are NOT a chat assistant.\nYou are a function.\n\nYour only job:\nExtract search keywords from the user text and return JSON.\n\nYou MUST output ONLY this format:\n{\"search_query\":\"...\"}\n\nNo greetings.\nNo explanations.\nNo emojis.\nNo markdown.\nNo extra text.\n\nIf you break the format, the system fails.\n\nExample:\nUser: Find papers about microscopy in 2025\nOutput: {\"search_query\":\"microscopy 2025\"}\n\nNow process this user message:\n`;\n\nreturn { system, user, has_year_constraint: $json.has_year_constraint, requested_year: $json.requested_year };\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        -224
      ],
      "id": "a77b5091-09d6-43cb-a36e-3a4a49ec9a48",
      "name": "Build prompt"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://127.0.0.1:11434/api/chat",
        "sendBody": true,
        "contentType": "raw",
        "rawContentType": "Content-Type: application/json",
        "body": "={{ JSON.stringify({\n  model: \"qwen3:4b\",\n  messages: [\n    { role: \"system\", content: $json.system },\n    { role: \"user\", content: $json.user }\n  ],\n  stream: false,\n  options: { temperature: 0 }\n}) }}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        -384,
        -224
      ],
      "id": "04c049c5-eff6-43c6-a337-8a1c8996e126",
      "name": "Ollama - extract query"
    },
    {
      "parameters": {
        "jsCode": "const content =\n  $json.message?.content\n  ?? $json.choices?.[0]?.message?.content\n  ?? $json.response\n  ?? \"\";\n\nconst text = String(content).trim();\n\n// Try to find JSON block\nconst first = text.indexOf(\"{\");\nconst last = text.lastIndexOf(\"}\");\n\nif (first !== -1 && last !== -1 && last > first) {\n  const jsonText = text.slice(first, last + 1);\n  try {\n    const parsed = JSON.parse(jsonText);\n    if (parsed.search_query) {\n      return { search_query: String(parsed.search_query).trim() };\n    }\n  } catch (e) {\n    // fall through to fallback\n  }\n}\n\n// Fallback: crude keyword extraction\n// Remove common filler words\nconst cleaned = text\n  .toLowerCase()\n  .replace(/find|papers|about|on|in|for|please|show|me|research/g, \"\")\n  .replace(/[^a-z0-9\\s]/g, \" \")\n  .replace(/\\s+/g, \" \")\n  .trim();\n\nif (!cleaned) {\n  throw new Error(\"Could not extract keywords from model output: \" + text);\n}\n\nreturn {\n  search_query: cleaned\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -160,
        -224
      ],
      "id": "77753ad5-cadd-4030-ad16-fc0b5b312232",
      "name": "Parse Ollama JSON"
    },
    {
      "parameters": {
        "url": "http://export.arxiv.org/api/query",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "search_query",
              "value": "={{ 'all:' + $json.search_query.replace(/\\s+/g, '+') }}"
            },
            {
              "name": "max_results",
              "value": "10"
            },
            {
              "name": "sortBy",
              "value": "submittedDate"
            },
            {
              "name": "sortOrder",
              "value": "descending"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        336,
        -736
      ],
      "id": "fc181524-7ca6-4759-a87a-6862e8a788af",
      "name": "ArXiv - query"
    },
    {
      "parameters": {
        "jsCode": "const xml = $json.body ?? $json.data ?? $json;\n\nconst entries = [...String(xml).matchAll(/<entry>([\\s\\S]*?)<\\/entry>/g)].map(m => {\n  const e = m[1];\n\n  const getTag = (tag) => {\n    const r = new RegExp(`<${tag}>([\\\\s\\\\S]*?)<\\\\/${tag}>`);\n    const mm = e.match(r);\n    return mm ? mm[1].replace(/\\s+/g, \" \").trim() : \"\";\n  };\n\n  const title = getTag(\"title\");\n  const summary = getTag(\"summary\");\n  const published = getTag(\"published\");\n  const id = getTag(\"id\");\n\n  const authors = [...e.matchAll(/<author>[\\s\\S]*?<name>(.*?)<\\/name>[\\s\\S]*?<\\/author>/g)]\n    .map(a => a[1].trim())\n    .join(\", \");\n\n  return {\n  title: title || \"No title\",\n  authors: authors || \"Unknown authors\",\n  date: published ? published.split(\"T\")[0] : \"Unknown date\",\n  abstract: summary ? (summary.length > 240 ? summary.slice(0, 240) + \"...\" : summary) : \"No abstract\",\n  raw_text: [title, summary, authors].filter(Boolean).join(\" \"),\n  link: id || \"No link\"\n};\n});\n\nreturn {\n  source: \"arxiv\",\n  papers: entries.map(p => ({\n    source: \"arxiv\",\n    title: p.title,\n    authors_venue_year: p.authors,\n    year: p.date !== \"Unknown date\" ? p.date.slice(0, 4) : \"\",\n    cited_by: null,\n    snippet: p.abstract,\n    link: p.link,\n    date: p.date\n  })),\n  count: entries.length\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -736
      ],
      "id": "616d21d8-d3cf-404c-a17a-f1709efe12a2",
      "name": "Parse ArXiv XML"
    },
    {
      "parameters": {
        "url": "https://serpapi.com/search.json",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "engine",
              "value": "google_scholar"
            },
            {
              "name": "q",
              "value": "={{$json.search_query}}"
            },
            {
              "name": "num",
              "value": "10"
            },
            {
              "name": "hl",
              "value": "en"
            },
            {
              "name": "api_key",
              "value": "YOUR_SERPAPI_KEY"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        336,
        -560
      ],
      "id": "dfbf67cb-486d-4fd0-a20d-8bdcc5469fc6",
      "name": "SerpAPI - Google Scholar"
    },
    {
      "parameters": {
        "jsCode": "const data = $json;\n\nconst results = (data.organic_results || []).slice(0, 10).map(r => {\n  const title = r.title || \"No title\";\n  const link = r.link || r.result_id || \"\";\n  const snippet = r.snippet || \"\";\n  const pubInfo = r.publication_info?.summary || \"\";\n  const citedBy = r.inline_links?.cited_by?.total ?? null;\n\n  // Try to extract a year from publication_info.summary (best-effort)\n  const yearMatch = String(pubInfo).match(/\\b(19|20)\\d{2}\\b/);\n  const year = yearMatch ? yearMatch[0] : \"\";\n\n  return {\n    source: \"scholar\",\n    title,\n    authors_venue_year: pubInfo,\n    year,\n    cited_by: citedBy,\n    snippet: snippet.length > 240 ? snippet.slice(0, 240) + \"...\" : snippet,\n    raw_text: [title, snippet, pubInfo].filter(Boolean).join(\" \"),\n    link\n  };\n});\n\nreturn {\n  source: \"scholar\",\n  count: results.length,\n  papers: results\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -560
      ],
      "id": "44c3c851-a176-480c-8778-a58d95a867ef",
      "name": "Parse SerpAPI Scholar"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.tavily.com/search",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer YOUR_TAVILY_API_KEY"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"query\": \"={{ $json.search_query + ' paper OR journal OR study filetype:pdf' }}\",\n  \"search_depth\": \"basic\",\n  \"max_results\": 10,\n  \"include_answer\": false,\n  \"include_raw_content\": false\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        336,
        -304
      ],
      "id": "d9d50bbe-9770-443b-9ddb-8f6775da2d04",
      "name": "Tavily - search"
    },
    {
      "parameters": {
        "jsCode": "const data = $json;\nconst results = (data.results || []).slice(0, 10).map(r => {\n  const title = r.title || \"No title\";\n  const link = r.url || \"\";\n  const snippet = r.content || r.snippet || \"\";\n  return {\n    source: \"tavily\",\n    title,\n    snippet: snippet.length > 240 ? snippet.slice(0, 240) + \"...\" : snippet,\n    link\n  };\n});\n\nreturn {\n  source: \"tavily\",\n  count: results.length,\n  papers: results\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        544,
        -304
      ],
      "id": "5b63d132-f193-4206-ae89-7182935bbc85",
      "name": "Parse Tavily"
    },
    {
      "parameters": {},
      "type": "n8n-nodes-base.merge",
      "typeVersion": 3.2,
      "position": [
        832,
        -144
      ],
      "id": "5858a9e3-c3b8-4a9e-8046-11d6a43792a4",
      "name": "Merge all results"
    },
    {
      "parameters": {
        "jsCode": "const data = $json || {};\n\nif (!data.data || !Array.isArray(data.data)) {\n  return {\n    source: \"semantic_scholar\",\n    count: 0,\n    papers: []\n  };\n}\n\nconst papers = (data.data || []).map(p => {\n  const authors = (p.authors || []).map(a => a.name).join(\", \");\n  return {\n    source: \"semantic_scholar\",\n    title: p.title || \"No title\",\n    authors_venue_year: [authors, p.venue, p.year].filter(Boolean).join(\" - \"),\n    year: p.year ? String(p.year) : \"\",\n    cited_by: p.citationCount ?? null,\n    snippet: p.abstract\n      ? (p.abstract.length > 240 ? p.abstract.slice(0, 240) + \"...\" : p.abstract)\n      : \"\",\n    raw_text: [\n    p.title || \"\",\n    p.abstract || \"\",\n    authors || \"\",\n    p.venue || \"\",\n    p.year ? String(p.year) : \"\"\n  ].filter(Boolean).join(\" \"),\n    link: p.url || \"\"\n  };\n});\n\nreturn {\n  source: \"semantic_scholar\",\n  count: papers.length,\n  papers\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        560,
        192
      ],
      "id": "f2745b94-67dd-48be-ae6b-c303cf5f3f85",
      "name": "Parse Semantic Scholar"
    },
    {
      "parameters": {
        "jsCode": "const text = String($json.chatInput || \"\").toLowerCase();\n\nlet hasYear = false;\nlet year = null;\n\n// Match explicit years\nconst yearMatch = text.match(/\\b(19|20)\\d{2}\\b/);\nif (yearMatch) {\n  hasYear = true;\n  year = yearMatch[0];\n}\n\n// Match relative time words\nif (\n  text.includes(\"latest\") ||\n  text.includes(\"recent\") ||\n  text.includes(\"this year\") ||\n  text.includes(\"last year\")\n) {\n  hasYear = true;\n}\n\nreturn {\n  original_query: $json.chatInput,\n  has_year_constraint: hasYear,\n  requested_year: year\n};\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -832,
        -224
      ],
      "id": "13d7514c-8a28-423e-ba91-e909dda6a683",
      "name": "Detect time intent"
    },
    {
      "parameters": {
        "jsCode": "const items = $input.all().map(i => i.json);\nconst query = $node[\"Parse Ollama JSON\"].json.search_query;\nconst hasYear = $node[\"Detect time intent\"].json.has_year_constraint;\n\nfunction simpleSimilarity(q, text) {\n  const qs = q.toLowerCase().split(/\\s+/);\n  const ts = text.toLowerCase();\n  let hit = 0;\n  for (const w of qs) {\n    if (ts.includes(w)) hit++;\n  }\n  return hit / qs.length;\n}\n\n// Flatten all papers\nlet all = [];\nfor (const it of items) {\n  if (it.papers) all.push(...it.papers);\n}\n\n// Normalize citation scale\nconst maxCite = Math.max(...all.map(p => p.cited_by || 0), 1);\n\nfor (const p of all) {\n  const contentScore = simpleSimilarity(query, p.raw_text || \"\");\n  let finalScore = contentScore;\n\n  if (!hasYear && p.cited_by !== null) {\n    const citeScore = Math.log(1 + p.cited_by) / Math.log(1 + maxCite);\n    finalScore = 0.8 * contentScore + 0.2 * citeScore;\n  }\n\n  p.content_score = contentScore;\n  p.final_score = finalScore;\n}\n\nreturn { papers: all };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1072,
        -144
      ],
      "id": "5bd2edfb-e7fd-4f18-a243-0032dbc77ae4",
      "name": "Score papers"
    },
    {
      "parameters": {
        "jsCode": "const input = $json.papers || [];\n\nconst seen = {};\nconst result = [];\n\nfor (const p of input) {\n  const key = (p.title || \"\").toLowerCase().replace(/[^a-z0-9]/g, \"\");\n  if (!seen[key]) {\n    seen[key] = p;\n    result.push(p);\n  } else {\n    if ((p.final_score || 0) > (seen[key].final_score || 0)) {\n      const idx = result.indexOf(seen[key]);\n      result[idx] = p;\n      seen[key] = p;\n    }\n  }\n}\n\nreturn { papers: result };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1280,
        -144
      ],
      "id": "21837269-8e1a-46d9-bab1-ac2316b5b2ad",
      "name": "Deduplicate papers"
    },
    {
      "parameters": {
        "jsCode": "const papers = $json.papers || [];\npapers.sort((a, b) => b.final_score - a.final_score);\nreturn { papers };"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        -144
      ],
      "id": "2e2417ff-d1bd-480b-86c7-ec665b7d63c3",
      "name": "Sort by relevance"
    },
    {
      "parameters": {
        "jsCode": "const papers = $json.papers || [];\nconst query = $node[\"Parse Ollama JSON\"].json.search_query;\n\nlet out = `Top relevant papers for: \"${query}\"\\n\\n`;\n\nif (!papers.length) {\n  return { text: \"No relevant papers found.\" };\n}\n\npapers.forEach((p, i) => {\n  out += `${i+1}) ${p.title}\\n`;\n  if (p.year) out += `Year: ${p.year} | `;\n  if (p.cited_by !== null) out += `Cited by: ${p.cited_by} | `;\n  out += `Source: ${p.source}\\n`;\n  out += `Score: ${p.final_score.toFixed(3)}\\n`;\n  if (p.snippet) out += `Abstract: ${p.snippet}\\n`;\n  if (p.link) out += `Link: ${p.link}\\n`;\n  out += `\\n`;\n});\n\nreturn { text: out };\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1728,
        -144
      ],
      "id": "c4d29d9e-d6e4-4cd0-a463-1af177be7999",
      "name": "Format research output"
    },
    {
      "parameters": {
        "url": "https://api.semanticscholar.org/graph/v1/paper/search",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "={{$json.search_query}}"
            },
            {
              "name": "limit",
              "value": "5"
            },
            {
              "name": "fields",
              "value": "title,authors,year,venue,abstract,citationCount,url"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "x-api-key",
              "value": "YOUR_SEMANTIC_SCHOLAR_API_KEY"
            }
          ]
        },
        "options": {
          "timeout": 30000
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.3,
      "position": [
        336,
        192
      ],
      "id": "bd0aee9c-23cf-484d-aed5-0a595157e460",
      "name": "Semantic Scholar – search",
      "retryOnFail": true,
      "alwaysOutputData": true,
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "amount": 2
      },
      "type": "n8n-nodes-base.wait",
      "typeVersion": 1.1,
      "position": [
        160,
        96
      ],
      "id": "a5d880e8-e6df-41d3-a93f-4a6a1db63d46",
      "name": "Semantic Search Wait",
      "webhookId": "f415c51a-dc34-4322-9c5b-12938b8ed0af"
    }
  ],
  "pinData": {},
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "Detect time intent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Build prompt": {
      "main": [
        [
          {
            "node": "Ollama - extract query",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Ollama JSON": {
      "main": [
        [
          {
            "node": "SerpAPI - Google Scholar",
            "type": "main",
            "index": 0
          },
          {
            "node": "Tavily - search",
            "type": "main",
            "index": 0
          },
          {
            "node": "ArXiv - query",
            "type": "main",
            "index": 0
          },
          {
            "node": "Semantic Search Wait",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse ArXiv XML": {
      "main": [
        [
          {
            "node": "Merge all results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Ollama - extract query": {
      "main": [
        [
          {
            "node": "Parse Ollama JSON",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ArXiv - query": {
      "main": [
        [
          {
            "node": "Parse ArXiv XML",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "SerpAPI - Google Scholar": {
      "main": [
        [
          {
            "node": "Parse SerpAPI Scholar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse SerpAPI Scholar": {
      "main": [
        [
          {
            "node": "Merge all results",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Tavily - search": {
      "main": [
        [
          {
            "node": "Parse Tavily",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Tavily": {
      "main": [
        [
          {
            "node": "Merge all results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Merge all results": {
      "main": [
        [
          {
            "node": "Score papers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Semantic Scholar": {
      "main": [
        [
          {
            "node": "Merge all results",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "Detect time intent": {
      "main": [
        [
          {
            "node": "Build prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Score papers": {
      "main": [
        [
          {
            "node": "Deduplicate papers",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Deduplicate papers": {
      "main": [
        [
          {
            "node": "Sort by relevance",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sort by relevance": {
      "main": [
        [
          {
            "node": "Format research output",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Semantic Scholar – search": {
      "main": [
        [
          {
            "node": "Parse Semantic Scholar",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Semantic Search Wait": {
      "main": [
        [
          {
            "node": "Semantic Scholar – search",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": false
  },
  "versionId": "e5a26dd6-59e7-4e01-8251-188c24a895fd",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "26d76892f2beb3802822db4bf354ffde9017164d6ee92e56e590b1c1e9440b2c"
  },
  "id": "FaxomjZyDWcmTd0n",
  "tags": []
}